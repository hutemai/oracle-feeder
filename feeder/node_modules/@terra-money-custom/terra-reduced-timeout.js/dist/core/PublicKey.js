"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.ValConsPublicKey = exports.LegacyAminoMultisigPublicKey = exports.SimplePublicKey = exports.PublicKey = void 0;
var json_1 = require("../util/json");
var keys_1 = require("@terra-money/terra.proto/cosmos/crypto/multisig/keys");
var any_1 = require("@terra-money/terra.proto/google/protobuf/any");
var keys_2 = require("@terra-money/terra.proto/cosmos/crypto/secp256k1/keys");
var keys_3 = require("@terra-money/terra.proto/cosmos/crypto/ed25519/keys");
var PublicKey;
(function (PublicKey) {
    function fromAmino(data) {
        switch (data.type) {
            case 'tendermint/PubKeySecp256k1':
                return SimplePublicKey.fromAmino(data);
            case 'tendermint/PubKeyMultisigThreshold':
                return LegacyAminoMultisigPublicKey.fromAmino(data);
            case 'tendermint/PubKeyEd25519':
                return ValConsPublicKey.fromAmino(data);
        }
    }
    PublicKey.fromAmino = fromAmino;
    function fromData(data) {
        switch (data['@type']) {
            case '/cosmos.crypto.secp256k1.PubKey':
                return SimplePublicKey.fromData(data);
            case '/cosmos.crypto.multisig.LegacyAminoPubKey':
                return LegacyAminoMultisigPublicKey.fromData(data);
            case '/cosmos.crypto.ed25519.PubKey':
                return ValConsPublicKey.fromData(data);
        }
    }
    PublicKey.fromData = fromData;
    function fromProto(pubkeyAny) {
        var typeUrl = pubkeyAny.typeUrl;
        if (typeUrl === '/cosmos.crypto.secp256k1.PubKey') {
            return SimplePublicKey.unpackAny(pubkeyAny);
        }
        else if (typeUrl === '/cosmos.crypto.multisig.LegacyAminoPubKey') {
            return LegacyAminoMultisigPublicKey.unpackAny(pubkeyAny);
        }
        else if (typeUrl === '/cosmos.crypto.ed25519.PubKey') {
            return ValConsPublicKey.unpackAny(pubkeyAny);
        }
        throw new Error("Pubkey type " + typeUrl + " not recognized");
    }
    PublicKey.fromProto = fromProto;
})(PublicKey = exports.PublicKey || (exports.PublicKey = {}));
var SimplePublicKey = /** @class */ (function (_super) {
    __extends(SimplePublicKey, _super);
    function SimplePublicKey(key) {
        var _this = _super.call(this) || this;
        _this.key = key;
        return _this;
    }
    SimplePublicKey.fromAmino = function (data) {
        return new SimplePublicKey(data.value);
    };
    SimplePublicKey.prototype.toAmino = function () {
        return {
            type: 'tendermint/PubKeySecp256k1',
            value: this.key,
        };
    };
    SimplePublicKey.fromData = function (data) {
        return new SimplePublicKey(data.key);
    };
    SimplePublicKey.prototype.toData = function () {
        return {
            '@type': '/cosmos.crypto.secp256k1.PubKey',
            key: this.key,
        };
    };
    SimplePublicKey.fromProto = function (pubkeyProto) {
        return new SimplePublicKey(Buffer.from(pubkeyProto.key).toString('base64'));
    };
    SimplePublicKey.prototype.toProto = function () {
        return keys_2.PubKey.fromPartial({
            key: Buffer.from(this.key, 'base64'),
        });
    };
    SimplePublicKey.prototype.packAny = function () {
        return any_1.Any.fromPartial({
            typeUrl: '/cosmos.crypto.secp256k1.PubKey',
            value: keys_2.PubKey.encode(this.toProto()).finish(),
        });
    };
    SimplePublicKey.unpackAny = function (pubkeyAny) {
        return SimplePublicKey.fromProto(keys_2.PubKey.decode(pubkeyAny.value));
    };
    return SimplePublicKey;
}(json_1.JSONSerializable));
exports.SimplePublicKey = SimplePublicKey;
var LegacyAminoMultisigPublicKey = /** @class */ (function (_super) {
    __extends(LegacyAminoMultisigPublicKey, _super);
    function LegacyAminoMultisigPublicKey(threshold, pubkeys) {
        var _this = _super.call(this) || this;
        _this.threshold = threshold;
        _this.pubkeys = pubkeys;
        return _this;
    }
    LegacyAminoMultisigPublicKey.fromAmino = function (data) {
        return new LegacyAminoMultisigPublicKey(Number.parseInt(data.value.threshold), data.value.pubkeys.map(function (p) { return SimplePublicKey.fromAmino(p); }));
    };
    LegacyAminoMultisigPublicKey.prototype.toAmino = function () {
        return {
            type: 'tendermint/PubKeyMultisigThreshold',
            value: {
                threshold: this.threshold.toFixed(),
                pubkeys: this.pubkeys.map(function (p) { return p.toAmino(); }),
            },
        };
    };
    LegacyAminoMultisigPublicKey.fromData = function (data) {
        return new LegacyAminoMultisigPublicKey(Number.parseInt(data.threshold), data.pubkeys.map(function (v) { return SimplePublicKey.fromData(v); }));
    };
    LegacyAminoMultisigPublicKey.prototype.toData = function () {
        return {
            '@type': '/cosmos.crypto.multisig.LegacyAminoPubKey',
            threshold: this.threshold.toFixed(),
            pubkeys: this.pubkeys.map(function (p) { return p.toData(); }),
        };
    };
    LegacyAminoMultisigPublicKey.fromProto = function (pubkeyProto) {
        return new LegacyAminoMultisigPublicKey(pubkeyProto.threshold, pubkeyProto.publicKeys.map(function (v) { return SimplePublicKey.unpackAny(v); }));
    };
    LegacyAminoMultisigPublicKey.prototype.toProto = function () {
        return keys_1.LegacyAminoPubKey.fromPartial({
            threshold: this.threshold,
            publicKeys: this.pubkeys.map(function (v) { return v.packAny(); }),
        });
    };
    LegacyAminoMultisigPublicKey.prototype.packAny = function () {
        return any_1.Any.fromPartial({
            typeUrl: '/cosmos.crypto.multisig.LegacyAminoPubKey',
            value: keys_1.LegacyAminoPubKey.encode(this.toProto()).finish(),
        });
    };
    LegacyAminoMultisigPublicKey.unpackAny = function (pubkeyAny) {
        return LegacyAminoMultisigPublicKey.fromProto(keys_1.LegacyAminoPubKey.decode(pubkeyAny.value));
    };
    return LegacyAminoMultisigPublicKey;
}(json_1.JSONSerializable));
exports.LegacyAminoMultisigPublicKey = LegacyAminoMultisigPublicKey;
var ValConsPublicKey = /** @class */ (function (_super) {
    __extends(ValConsPublicKey, _super);
    function ValConsPublicKey(key) {
        var _this = _super.call(this) || this;
        _this.key = key;
        return _this;
    }
    ValConsPublicKey.fromAmino = function (data) {
        return new ValConsPublicKey(data.value);
    };
    ValConsPublicKey.prototype.toAmino = function () {
        return {
            type: 'tendermint/PubKeyEd25519',
            value: this.key,
        };
    };
    ValConsPublicKey.fromData = function (data) {
        return new ValConsPublicKey(data.key);
    };
    ValConsPublicKey.prototype.toData = function () {
        return {
            '@type': '/cosmos.crypto.ed25519.PubKey',
            key: this.key,
        };
    };
    ValConsPublicKey.fromProto = function (pubkeyProto) {
        return new ValConsPublicKey(Buffer.from(pubkeyProto.key).toString('base64'));
    };
    ValConsPublicKey.prototype.toProto = function () {
        return keys_2.PubKey.fromPartial({
            key: Buffer.from(this.key, 'base64'),
        });
    };
    ValConsPublicKey.prototype.packAny = function () {
        return any_1.Any.fromPartial({
            typeUrl: '/cosmos.crypto.ed25519.PubKey',
            value: keys_3.PubKey.encode(this.toProto()).finish(),
        });
    };
    ValConsPublicKey.unpackAny = function (pubkeyAny) {
        return ValConsPublicKey.fromProto(keys_3.PubKey.decode(pubkeyAny.value));
    };
    return ValConsPublicKey;
}(json_1.JSONSerializable));
exports.ValConsPublicKey = ValConsPublicKey;
//# sourceMappingURL=PublicKey.js.map